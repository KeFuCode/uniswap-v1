# Uniswap v1

## IDEAs

1. 学习的最佳方式是教给他人。其次是亲自动手去做。我决定将这两种方式结合起来。
2. 我们只会处理智能合约：为智能合约构建前端也是一个重要且有趣的任务，但它超出了本系列的范围。
3. 市场做市商是为市场提供流动性（交易资产）的实体。流动性是交易的基础：如果你想卖出某物品但没有人购买，那么就不会有交易。一些交易对具有高流动性（例如BTC-USDT），但有些交易对则没有或者流动性很低（例如一些骗局或不良的小型加密货币）。
4. 供求法则：需求越高（你想要获得的产出量越大）相对于供应（储备），价格就越高（你获得的就越少）。

## Q&A

Q: Uniswap 是什么？  
A: Uniswap是一个去中心化交易所（DEX），旨在成为中心化交易所的替代品。它运行在以太坊区块链上，是完全自动化的：没有管理员、经理或拥有特权访问的用户。

Q：DEX的开发者投入自己的资金（或投资者的资金）并成为市场制造商，可行吗？    
A：去中心化交易所必须具备足够（或大量的）流动性，才能发挥作用并作为中心化交易所的替代品。这不是一个现实的解决方案，因为考虑到DEX允许任何代币之间的交易，他们需要大量的资金来提供足够的流动性。此外，这将使DEX变得集中化：作为唯一的市场制造商，开发者将拥有很大的权力。

Q：Uniswap 提供流动性的解决方案是什么？  
A：更好的解决方案是允许任何人成为市场做市商，这就是使Uniswap成为自动化市场做市商的原因：任何用户都可以将他们的资金存入交易对中（并从中受益）。

Q：除了 DEX 之外，Uniswap 还有什么其他用途？为什么？  
A：1.Uniswap扮演的另一个重要角色是价格预言机。价格预言机是从中心化交易所获取代币价格并将其提供给智能合约的服务 - 这些价格通常很难操纵，因为中心化交易所的交易量通常非常大。然而，尽管没有那么大的交易量，Uniswap仍然可以作为价格预言机。2.Uniswap充当二级市场，吸引套利者通过Uniswap和中心化交易所之间的价格差异获利。这使得Uniswap池中的价格尽可能接近更大交易所的价格。而这不可能没有适当的定价和储备平衡功能。

Q：Uniswap的核心是什么？  
A：Uniswap的核心是恒定乘积函数：x*y=k 。其中 x 是以太储备， y 是代币储备（或反之）， k 是一个常数。Uniswap要求 k 无论 x 或 y 的储备量如何，都保持不变。当你用以太换取代币时，你需要将以太存入合约中，并获得一定数量的代币作为回报。Uniswap确保每次交易后 k 保持不变（这并不完全正确，稍后我们会看到为什么）。

Q：Uniswap为什么不使用 Px = y/x, Py = x/y 这样的定价函数？  
A：它允许耗尽交易所的资金，而这并不是我们希望发生的事情。（如果我们用2000个代币换取以太币会发生什么呢？我们将得到1000个以太币，这是我们在合约中拥有的全部！交易所将被耗尽！）这是因为定价函数属于一个常数和公式，它将 k 定义为 x 和 y 的常数和。这个常数和公式的函数是一条直线。它穿越 x 和 y 轴，这意味着它允许0出现在其中任何一个轴上！我们绝对不希望这样。当我们交易的 token 数量与储备相比非常小的时候，它是正确的。

Q：为什么 x*y=k 可以得到更好的定价函数？  
A：根据公式，无论储备（ x 和 y ）是什么， k 都保持不变。每次交易都会增加以太币或代币的储备，并减少代币或以太币的储备。将这个逻辑用公式表示：(x + Δx)(y - Δy) = xy 。根据这个公式，我们现在可以找到 Δy ，其中 Δx 是我们交易的 ether 或 token 的数量， Δy 是我们以交换方式获得的 token 或 ether 的数量。Δy = y*Δx / x+Δx 。现在我们用1个以太坊可以获得1.998个代币，而用2个代币可以获得0.999个以太坊。这些数量与之前的定价函数产生的数量非常接近。然而，它们稍微小一些。双曲线永远不会穿过 x 或 y ，因此两个储备都永远不会为0。这使得储备是无限的！

Q：使用 x*y=k 有什么缺点？  
A：x*y=k 价格函数会导致价格滑点。交易的代币数量相对于储备越大，价格就越高。这是我们在测试中看到的情况：我们得到的结果略低于我们的预期。这可能被视为恒定产品市场制造商的一个缺点（因为每次交易都会有滑点），然而这也是保护资金池不被耗尽的机制。

Q: 当前版本的 Uniswap 还存在哪些问题？  
A: 1.增加新的流动性可能会引起巨大的价格变动。2.流动性提供者不会获得奖励；所有的交换都是免费的。3.无法移除流动性。4.无法交换ERC20代币（链式交换）。5.Factory还没有实施。

Q：实现最简版本 Uniswap 的思路是什么？ 
A：DEX的核心是什么 => 流动性 => 提供流动性（实现 AddLiquidity 函数） => 查看流动性（实现 getReserve 函数）=> 获得 token/eth 价格（实现 getPrice 函数）=> 优化 token/eth 价格计算（ 实现 getAmount 函数；实现 getTokenAmount 函数；实现 getEthAmount 函数） => 实现 token/eth swap 功能（实现 ethToTokenSwap 函数；实现 tokenToEthSwap 函数）