# Uniswap v1

## IDEAs

1. 学习的最佳方式是教给他人。其次是亲自动手去做。我决定将这两种方式结合起来。
2. 我们只会处理智能合约：为智能合约构建前端也是一个重要且有趣的任务，但它超出了本系列的范围。
3. 市场做市商是为市场提供流动性（交易资产）的实体。流动性是交易的基础：如果你想卖出某物品但没有人购买，那么就不会有交易。一些交易对具有高流动性（例如BTC-USDT），但有些交易对则没有或者流动性很低（例如一些骗局或不良的小型加密货币）。
4. 供求法则：需求越高（你想要获得的产出量越大）相对于供应（储备），价格就越高（你获得的就越少）。

## Q&A

### Section 1

Q: Uniswap 是什么？  
A: Uniswap是一个去中心化交易所（DEX），旨在成为中心化交易所的替代品。它运行在以太坊区块链上，是完全自动化的：没有管理员、经理或拥有特权访问的用户。

Q：DEX的开发者投入自己的资金（或投资者的资金）并成为市场制造商，可行吗？    
A：去中心化交易所必须具备足够（或大量的）流动性，才能发挥作用并作为中心化交易所的替代品。这不是一个现实的解决方案，因为考虑到DEX允许任何代币之间的交易，他们需要大量的资金来提供足够的流动性。此外，这将使DEX变得集中化：作为唯一的市场制造商，开发者将拥有很大的权力。

Q：Uniswap 提供流动性的解决方案是什么？  
A：更好的解决方案是允许任何人成为市场做市商，这就是使Uniswap成为自动化市场做市商的原因：任何用户都可以将他们的资金存入交易对中（并从中受益）。

Q：除了 DEX 之外，Uniswap 还有什么其他用途？为什么？  
A：1.Uniswap扮演的另一个重要角色是价格预言机。价格预言机是从中心化交易所获取代币价格并将其提供给智能合约的服务 - 这些价格通常很难操纵，因为中心化交易所的交易量通常非常大。然而，尽管没有那么大的交易量，Uniswap仍然可以作为价格预言机。2.Uniswap充当二级市场，吸引套利者通过Uniswap和中心化交易所之间的价格差异获利。这使得Uniswap池中的价格尽可能接近更大交易所的价格。而这不可能没有适当的定价和储备平衡功能。

Q：Uniswap的核心是什么？  
A：Uniswap的核心是恒定乘积函数：x*y=k 。其中 x 是以太储备， y 是代币储备（或反之）， k 是一个常数。Uniswap要求 k 无论 x 或 y 的储备量如何，都保持不变。当你用以太换取代币时，你需要将以太存入合约中，并获得一定数量的代币作为回报。Uniswap确保每次交易后 k 保持不变（这并不完全正确，稍后我们会看到为什么）。

Q：Uniswap为什么不使用 Px = y/x, Py = x/y 这样的定价函数？  
A：它允许耗尽交易所的资金，而这并不是我们希望发生的事情。（如果我们用2000个代币换取以太币会发生什么呢？我们将得到1000个以太币，这是我们在合约中拥有的全部！交易所将被耗尽！）这是因为定价函数属于一个常数和公式，它将 k 定义为 x 和 y 的常数和。这个常数和公式的函数是一条直线。它穿越 x 和 y 轴，这意味着它允许0出现在其中任何一个轴上！我们绝对不希望这样。当我们交易的 token 数量与储备相比非常小的时候，它是正确的。

Q：为什么 x*y=k 可以得到更好的定价函数？  
A：根据公式，无论储备（ x 和 y ）是什么， k 都保持不变。每次交易都会增加以太币或代币的储备，并减少代币或以太币的储备。将这个逻辑用公式表示：(x + Δx)(y - Δy) = xy 。根据这个公式，我们现在可以找到 Δy ，其中 Δx 是我们交易的 ether 或 token 的数量， Δy 是我们以交换方式获得的 token 或 ether 的数量。Δy = y*Δx / x+Δx 。现在我们用1个以太坊可以获得1.998个代币，而用2个代币可以获得0.999个以太坊。这些数量与之前的定价函数产生的数量非常接近。然而，它们稍微小一些。双曲线永远不会穿过 x 或 y ，因此两个储备都永远不会为0。这使得储备是无限的！

Q：使用 x*y=k 有什么缺点？  
A：x*y=k 价格函数会导致价格滑点。交易的代币数量相对于储备越大，价格就越高。这是我们在测试中看到的情况：我们得到的结果略低于我们的预期。这可能被视为恒定产品市场制造商的一个缺点（因为每次交易都会有滑点），然而这也是保护资金池不被耗尽的机制。

Q: 当前版本的 Uniswap 还存在哪些问题？  
A: 1.增加新的流动性可能会引起巨大的价格变动。2.流动性提供者不会获得奖励；所有的交换都是免费的。3.无法移除流动性。4.无法交换ERC20代币（链式交换）。5.Factory还没有实施。

Q：实现最简版本 Uniswap 的思路是什么？ 
A：DEX的核心是什么 => 流动性 => 提供流动性（实现 AddLiquidity 函数） => 查看流动性（实现 getReserve 函数）=> 获得 token/eth 价格（实现 getPrice 函数）=> 优化 token/eth 价格计算（ 实现 getAmount 函数；实现 getTokenAmount 函数；实现 getEthAmount 函数） => 实现 token/eth swap 功能（实现 ethToTokenSwap 函数；实现 tokenToEthSwap 函数）

### Section 2

Q: addLiquidity 提供流动性的函数存在什么问题？
```solidity
function addLiquidity(uint256 _amount) public payable {
    IERC20 token = IERC20(tokenAddress);
    token.transferFrom(msg.sender, address(this), _amount);
}
```
A: 价格操纵。它允许在任何时间点显著改变价格，当用户添加流动性时，他们可以自由地选择以太币和ERC20代币的数量，而这两种资产的比例决定了交易对的价格。如果用户添加的这两种资产的比例与当前的市场价格严重不符，那么这将显著改变交易对的价格。（假设当前交易对的价格是1个以太币换取100个ERC20代币。然后有一个用户执行了addLiquidity函数，他提供了1个以太币和10个ERC20代币。由于他提供的ERC20代币数量远低于市场价格，这将会显著提高交易对的价格，从1个以太币换取100个ERC20代币变为1个以太币换取10个ERC20代币。）这样的价格变动是不理想的，因为它可能会被恶意用户利用来进行价格操纵。我们希望去中心化交易所的价格尽可能接近中心化交易所的价格，以便我们的交易合约能够作为一个准确的价格预言机。一个更好的addLiquidity函数应该强制执行当前的储备比率，即用户添加的以太币和ERC20代币的比例必须与当前的市场价格相符。

Q：向 token/swap 池中添加流动性应该遵循什么样的原则？
A：我们必须确保在池中已经建立的比例相同的情况下增加额外的流动性。同时，当储备金为空时，即当池尚未初始化时，我们希望允许以任意比例提供流动性。这是一个重要的时刻，因为这是最初确定价格的时候。（1.我们必须确保在池中已经建立的比例相同的情况下增加额外的流动性。同时，当储备金为空时，即当池尚未初始化时，我们希望允许以任意比例提供流动性。这是一个重要的时刻，因为这是最初确定价格的时候。2.在有流动性时，强制执行已建立的储备比例。）

Q：为什么要奖励流动性提供者（提供 token）？  
A：如果他们没有得到激励，他们就不会提供流动性，因为没有人会把他们的代币放在第三方合约中，却得不到任何回报。此外，这种奖励不应该由我们支付，因为我们需要获得投资或发行通胀性代币来资助它。

Q：用什么方案奖励流动性提供者？  
A：唯一的好解决方案是在每次代币交换中收取一小笔费用，并将累积的费用分配给流动性提供者。这也似乎非常公平：用户（交易者）为其他人提供的服务（流动性）付费。为了使奖励公平，我们需要按照流动性提供者的贡献比例来奖励他们，即他们提供的流动性数量。如果有人提供了池子流动性的50%，那么他们应该获得累积费用的50%。

Q：如何实现奖励流动性提供者？  
A：这个任务看起来相当复杂，有一个优雅的解决方案：LP token 。LP token 基本上是以 ERC20 token 形式发行给提供流动性的提供者作为交换。事实上，LP token 就是股份：1.你通过提供流动性来获得LP token。2.你获得的 token 数量与你在资金池储备中的流动性份额成比例。3.费用按照您持有的 token 数量进行比例分配。4.LP token 可以兑换回流动性和累积的费用。

Q: 如何计算发行的LP代币数量?  
A: 我们需要满足一些要求：1.每一股发行的股份都必须始终正确。当有人在我之后存入或提取流动性时，我的股份必须保持正确。2.以太坊上的写操作（例如在合约中存储新数据或更新现有数据）非常昂贵。因此，我们希望降低LP token的维护成本（即我们不希望运行定期重新计算和更新份额的计划任务）。

Q：发行 LP token 需要设置数量上限吗？ 为什么？ 
A：不需要数量上限。  
a.有数量上限。如果发行了大量的代币（比如10亿个），并打算将这些代币分配给为其项目提供流动性的用户。1.如果DEX的开发者将所有代币一次性全部分发出去，那么第一个流动性提供者会得到全部的10亿个代币，然后第二个流动性提供者进来的时候，他们就需要重新计算已经发出的代币份额，这是因为第一个流动性提供者不能保持他的10亿份额，需要把一部分份额让给第二个流动性提供者。每当有新的流动性提供者加入时，都需要重新计算份额，这是非常昂贵的，因为在区块链上进行计算和修改数据都需要消耗gas。2.如果DEX的开发者最初只分发一部分代币，这样在新的流动性提供者加入时，他们可以直接发行新的代币，而不需要重新计算已经发出的代币份额。然而，这种方式也有一个问题，那就是当所有的代币都发行完了，即达到了供应限制时，他们就需要重新分配现有的份额，这也是非常昂贵的。  
b.无数量上限。唯一的好解决方案似乎是根本没有供应限制，并在增加新的流动性时铸造新的代币。这样可以实现无限增长，并且如果我们使用适当的公式，当增加或减少流动性时，所有发行的股份将保持正确（按比例缩放）。幸运的是，通胀不会降低LP代币的价值，因为它们始终由一定数量的与发行代币数量无关的流动性支持。

Q：当流动性被存入时，如何实现计算铸造的LP代币数量？  
A：使用公式 `amountMinted = totalAmonut * ethDeposited / ethReserve` 计算。每个流动性存款按照以太储备中存入以太币的份额比例发行LP代币。
```solidity
uint256 ethReserve = address(this).balance - msg.value;
// uint256 liquidity = ((totalSupply()+liquidity) * msg.value) / address(this).balance; // 化简后与下面代码相同
uint256 liquidity = (totalSupply() * msg.value) / ethReserve; 
```

Q：在开始收取 swap 费用之前，需要考虑哪些问题？
A：1.我们想用 ether 还是 token 收取费用？我们想用 ether 还是 token 向流动性提供者支付奖励？2.如何从每次交换中收取一笔小额固定费用？3.如何按照贡献比例将累积费用分配给流动性提供者？

Q：如何实现从每次交换中收取一笔小额固定费用？  
A：
GPT：
为什么引入fee之后，getAmount计算方式改变了。请举例帮助我理解。
引入fee之前：return (inputAmount * outputReserve) / (inputReserve + inputAmount);
引入fee之后：uint256 inputAmountWithFee = inputAmount * 99;uint256 numerator = inputAmountWithFee * outputReserve;uint256 denominator = (inputReserve * 100) + inputAmountWithFee;return numerator / denominator;

Q：如何实现移除流动性？  
A：为了移除流动性，我们可以再次使用LP代币：我们不需要记住每个流动性提供者存入的金额，可以根据LP代币的份额计算移除的流动性金额。
```solidity
uint256 ethAmount = (address(this).balance * _amount) / totalSupply();
uint256 tokenAmount = (getReserve() * _amount) / totalSupply();
```

Q：为什么会发生无常损失（impermanent loss）？
A：当流动性被移除时， ether 和 token 都会以平衡的方式返还，数量当然也是平衡的。这就是导致无常损失的时刻：储备比例随着时间的推移而改变，跟随其在美元价格上的变化。当流动性被移除时，余额可能与存入流动性时不同。这意味着你会得到不同数量的 ether 和 token，它们的总价值可能会低于如果你只是将它们保留在钱包中的情况。
GPT：举例帮助理解

Q：
A：
GPT：为了计算金额，我们将储备金乘以LP代币的份额

Q：
A：
GPT：LP奖励和无常损失演示（例子理解不够）